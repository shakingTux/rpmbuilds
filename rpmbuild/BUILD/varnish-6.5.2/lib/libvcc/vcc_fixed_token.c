/*
 * NB:  This file is machine generated, DO NOT EDIT!
 *
 * Edit and run lib/libvcc/generate.py instead.
 */



#include "config.h"

#include "vcc_compile.h"

#define M1()	do {*q = p + 1; return (p[0]); } while (0)
#define M2(c,t)	do {if (p[1] == (c)) { *q = p + 2; return (t); }} while (0)

unsigned
vcl_fixed_token(const char *p, const char **q)
{

	switch (p[0]) {
	case '!':
		M2('=', T_NEQ);
		M2('~', T_NOMATCH);
		M1();
	case '%':
		M1();
	case '&':
		M2('&', T_CAND);
		M1();
	case '(':
		M1();
	case ')':
		M1();
	case '*':
		M2('=', T_MUL);
		M1();
	case '+':
		M2('+', T_INC);
		M2('=', T_INCR);
		M1();
	case ',':
		M1();
	case '-':
		M2('-', T_DEC);
		M2('=', T_DECR);
		M1();
	case '.':
		M1();
	case '/':
		M2('=', T_DIV);
		M1();
	case ';':
		M1();
	case '<':
		M2('<', T_SHL);
		M2('=', T_LEQ);
		M1();
	case '=':
		M2('=', T_EQ);
		M1();
	case '>':
		M2('=', T_GEQ);
		M2('>', T_SHR);
		M1();
	case '{':
		M1();
	case '|':
		M2('|', T_COR);
		M1();
	case '}':
		M1();
	case '~':
		M1();
	default:
		return (0);
	}
}

const char * const vcl_tnames[256] = {
	['!'] = "'!'",
	['%'] = "'%'",
	['&'] = "'&'",
	['('] = "'('",
	[')'] = "')'",
	['*'] = "'*'",
	['+'] = "'+'",
	[','] = "','",
	['-'] = "'-'",
	['.'] = "'.'",
	['/'] = "'/'",
	[';'] = "';'",
	['<'] = "'<'",
	['='] = "'='",
	['>'] = "'>'",
	['{'] = "'{'",
	['|'] = "'|'",
	['}'] = "'}'",
	['~'] = "'~'",
	[CBLOB] = "CBLOB",
	[CNUM] = "CNUM",
	[CSRC] = "CSRC",
	[CSTR] = "CSTR",
	[EOI] = "EOI",
	[FNUM] = "FNUM",
	[ID] = "ID",
	[T_CAND] = "&&",
	[T_COR] = "||",
	[T_DEC] = "--",
	[T_DECR] = "-=",
	[T_DIV] = "/=",
	[T_EQ] = "==",
	[T_GEQ] = ">=",
	[T_INC] = "++",
	[T_INCR] = "+=",
	[T_LEQ] = "<=",
	[T_MUL] = "*=",
	[T_NEQ] = "!=",
	[T_NOMATCH] = "!~",
	[T_SHL] = "<<",
	[T_SHR] = ">>",
};

void
vcl_output_lang_h(struct vsb *sb)
{

	/* ../include/vdef.h */

	VSB_cat(sb, "/* ---===### include/vdef.h ###===--- */\n\n");
	VSB_cat(sb, "/*-\n * Copyright (c) 2006 Verdens Gang AS\n"
	    " * Copyright (c) 2012 Fastly Inc\n * Copyright (c) 2006-2015 "
	    "Varnish Software AS\n * All rights reserved.\n *\n"
	    " * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>\n"
	    " * Author: Rogier 'DocWilco' Mulhuijzen <rogier@fastly.com>\n"
	    " *\n * Inspired by FreeBSD's <sys/cdefs.h>\n *\n * SPDX-License-"
	    "Identifier: BSD-2-Clause\n *\n * Redistribution and use in "
	    "source and binary forms, with or without\n * modification, "
	    "are permitted provided that the following conditions\n"
	    " * are met:\n * 1. Redistributions of source code must retain "
	    "the above copyright\n *    notice, this list of conditions "
	    "and the following disclaimer.\n * 2. Redistributions in binary "
	    "form must reproduce the above copyright\n *    notice, this "
	    "list of conditions and the following disclaimer in the\n"
	    " *    documentation and/or other materials provided with the "
	    "distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "
	    "AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED "
	    "WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED "
	    "WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
	    "PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIB"
	    "UTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, "
	    "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, "
	    "BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n"
	    " * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
	    "INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,"
	    " WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING "
	    "NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE "
	    "USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n"
	    " * SUCH DAMAGE.\n *\n * Names of the form \"v_[a-z_]*_\" is "
	    "reserved for this file.\n *\n * This file should always be "
	    "the first non <...> include in a .c file.\n */\n\n"
	    "#ifdef VDEF_H_INCLUDED\n#  error \"vdef.h included multiple "
	    "times\"\n#endif\n#define VDEF_H_INCLUDED\n\n/* Safe printf "
	    "into a fixed-size buffer */\n#define bprintf(buf, fmt, ...)\t"
	    "\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint ibprintf;\t"
	    "\t\t\t\t\t\\\n\t\tibprintf = snprintf(buf, sizeof buf, fmt, "
	    "__VA_ARGS__);\t\\\n\t\tassert(ibprintf >= 0 && ibprintf < "
	    "(int)sizeof buf);\t\\\n\t} while (0)\n\n/* Safe printf into "
	    "a fixed-size buffer */\n#define vbprintf(buf, fmt, ap)\t\t\t"
	    "\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint ivbprintf;\t\t\t"
	    "\t\t\t\\\n\t\tivbprintf = vsnprintf(buf, sizeof buf, fmt, "
	    "ap);\t\\\n\t\tassert(ivbprintf >= 0 && ivbprintf < (int)sizeof "
	    "buf);\t\\\n\t} while (0)\n\n/* Safe strcpy into a fixed-size "
	    "buffer */\n#define bstrcpy(dst, src)\t\t\t\t\t\t\\\n"
	    "\tdo {\t\t\t\t\t\t\t\t\\\n\t\tassert(strlen(src) + 1 <= sizeof "
	    "(dst));\t\t\\\n\t\tstrcpy((dst), (src));\t\t\t\t\t\\\n"
	    "\t} while (0)\n\n// TODO #define strcpy BANNED\n// TODO then "
	    "revert 0fa4baead49f0a45f68d3db0b7743c5e4e93ad4d\n"
	    "// TODO and replace with flexelint exception\n\n/* Close and "
	    "discard filedescriptor */\n#define closefd(fdp)\t\t\t\t\\\n"
	    "\tdo {\t\t\t\t\t\\\n\t\tassert(*(fdp) >= 0);\t\t\\\n"
	    "\t\tAZ(close(*(fdp)));\t\t\\\n\t\t*(fdp) = -1;\t\t\t\\\n"
	    "\t} while (0)\n\n#ifndef __GNUC_PREREQ__\n# if defined __GNUC__ "
	    "&& defined __GNUC_MINOR__\n#  define __GNUC_PREREQ__(maj, "
	    "min) \\\n\t(__GNUC__ > (maj) || (__GNUC__ == (maj) && __GNUC_MIN"
	    "OR__ >= (min)))\n# else\n#  define __GNUC_PREREQ__(maj, min) "
	    "0\n# endif\n#endif\n\n#if __GNUC_PREREQ__(2, 95) || defined(__IN"
	    "TEL_COMPILER)\n#  define v_printflike_(f,a) __attribute__((forma"
	    "t(printf, f, a)))\n#else\n#  define v_printflike_(f,a)\n"
	    "#endif\n\n#define v_noreturn_ __attribute__((__noreturn__))\n"
	    "\n#ifdef __GNUC__\n#  define v_deprecated_ __attribute__((deprec"
	    "ated))\n#else\n#  define v_deprecated_\n#endif\n\n"
	    "#if __GNUC_PREREQ__(4,4) // added 2008-07-23\n#  define v_dont_o"
	    "ptimize __attribute__((optimize(\"O\")))\n#else\n"
	    "#  define v_dont_optimize\n#endif\n\n/**************************"
	    "*******************************************\n * Pointer alignmen"
	    "t magic\n */\n\n#if defined(__sparc__)\n/* NB: Overbroad test "
	    "for 32bit userland on 64bit SPARC cpus. */\n#  define PALGN\t"
	    "    (sizeof(double) - 1)\t/* size of alignment */\n"
	    "#else\n#  define PALGN\t    (sizeof(void *) - 1)\t/* size "
	    "of alignment */\n#endif\n#define PAOK(p)\t    (((uintptr_t)(p) "
	    "& PALGN) == 0)\t/* is aligned */\n#define PRNDDN(p)   ((uintptr_"
	    "t)(p) & ~PALGN)\t\t/* Round down */\n#define PRNDUP(p)   (((uint"
	    "ptr_t)(p) + PALGN) & ~PALGN)\t/* Round up */\n\n/***************"
	    "******************************************************\n"
	    " * To be used as little as possible to wash off const/volatile "
	    "etc.\n */\n#define TRUST_ME(ptr)\t((void*)(uintptr_t)(ptr))\n"
	    "\n/*************************************************************"
	    "*********\n * Generic power-2 rounding macros\n */\n"
	    "\n#define PWR2(x)     ((((x)-1UL)&(x))==0)\t\t/* Is a power "
	    "of two */\n#define RDN2(x, y)  ((x)&(~((uintptr_t)(y)-1UL)))\t"
	    "/* PWR2(y) true */\n#define RUP2(x, y)  (((x)+((y)-1))&(~((uintp"
	    "tr_t)(y)-1UL))) /* PWR2(y) true */\n\n/*************************"
	    "*********************************************\n * FlexeLint "
	    "and compiler shutuppery\n */\n\n/*\n * In OO-light situations, "
	    "functions have to match their prototype\n * even if that means "
	    "not const'ing a const'able argument.\n * The typedef should "
	    "be specified as argument to the macro.\n */\n#define v_matchprot"
	    "o_(xxx)\t\t/*lint --e{818} */\n\n/*\n * State variables may "
	    "change value before we have considered the\n * previous value\n"
	    " */\n#define v_statevariable_(varname)\tvarname /*lint -esym(838"
	    ",varname) */\n\n#ifdef __SUNPRO_C\n#  define NEEDLESS(s)\t\t"
	    "{}\n#else\n#  define NEEDLESS(s)\t\ts\n#endif\n\n"
	    "#if __GNUC_PREREQ__(2, 7)\n#  define v_unused_ __attribute__((__"
	    "unused__))\n#else\n#  define v_unused_\n#endif\n\n"
	    "/* VTIM API overhaul WIP */\ntypedef double vtim_mono;\n"
	    "typedef double vtim_real;\ntypedef double vtim_dur;\n"
	);
	VSB_cat(sb, "\n");

	/* ../include/vrt.h */

	VSB_cat(sb, "/* ---===### include/vrt.h ###===--- */\n\n");
	VSB_cat(sb, "/*- * Copyright (c) 2006 Verdens Gang AS\n"
	    " * Copyright (c) 2006-2015 Varnish Software AS\n * All rights "
	    "reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>"
	    "\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n"
	    " * Redistribution and use in source and binary forms, with "
	    "or without\n * modification, are permitted provided that the "
	    "following conditions\n * are met:\n * 1. Redistributions of "
	    "source code must retain the above copyright\n *    notice, "
	    "this list of conditions and the following disclaimer.\n"
	    " * 2. Redistributions in binary form must reproduce the above "
	    "copyright\n *    notice, this list of conditions and the followi"
	    "ng disclaimer in the\n *    documentation and/or other materials"
	    " provided with the distribution.\n *\n * THIS SOFTWARE IS "
	    "PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n"
	    " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED"
	    " TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS "
	    "FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT "
	    "SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, "
	    "INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
	    " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
	    "SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS;"
	    " OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY "
	    "OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR "
	    "TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n"
	    " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE "
	    "POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Runtime support for "
	    "compiled VCL programs and VMODs.\n *\n * NB: When this file "
	    "is changed, lib/libvcc/generate.py *MUST* be rerun.\n"
	    " */\n\n#ifdef CACHE_H_INCLUDED\n#  error \"vrt.h included "
	    "after cache.h - they are inclusive\"\n#endif\n\n#ifdef VRT_H_INC"
	    "LUDED\n#  error \"vrt.h included multiple times\"\n"
	    "#endif\n#define VRT_H_INCLUDED\n\n#ifndef VDEF_H_INCLUDED\n"
	    "#  error \"include vdef.h before vrt.h\"\n#endif\n"
	    "\n/*************************************************************"
	    "**********\n * Major and minor VRT API versions.\n"
	    " *\n * Whenever something is added, increment MINOR version\n"
	    " * Whenever something is deleted or changed in a way which "
	    "is not\n * binary/load-time compatible, increment MAJOR version\n"
	    " *\n * 12.0 (2020-09-15)\n *\tAdded VRT_DirectorResolve()\n"
	    " *\tAdded VCL_STRING VRT_BLOB_string(VRT_CTX, VCL_BLOB)\n"
	    " *\t[cache.h] WS_Reserve() removed\n *\t[cache.h] WS_Printf() "
	    "changed\n *\t[cache.h] WS_ReservationSize() added\n"
	    " *\t[cache.h] WS_Front() deprecated\n *\t[cache.h] WS_Reservatio"
	    "n() added\n * 11.0 (2020-03-16)\n *\tChanged type of vsa_suckadd"
	    "r_len from int to size_t\n *\tNew prefix_{ptr|len} fields "
	    "in vrt_backend\n *\tVRT_HashStrands32() added\n *\tVRT_l_resp_bo"
	    "dy() changed\n *\tVRT_l_beresp_body() changed\n *\tVRT_Format_Pr"
	    "oxy() added\t// transitional interface\n *\tVRT_AllocStrandsWS()"
	    " added\n * 10.0 (2019-09-15)\n *\tVRT_UpperLowerStrands added.\n"
	    " *\tVRT_synth_page now takes STRANDS argument\n *\tVRT_hashdata("
	    ") now takes STRANDS argument\n *\tVCL_BOOL VRT_Strands2Bool(VCL_"
	    "STRANDS) added.\n *\tVRT_BundleStrands() moved to vcc_interface."
	    "h\n *\tVRT_VCL_{Busy|Unbusy} changed to VRT_VCL_{Prevent|Allow}_"
	    "Cold\n *\tVRT_re[fl]_vcl changed to VRT_VCL_{Prevent|Allow}_Disc"
	    "ard\n *\tVRT_Vmod_{Init|Unload} moved to vcc_interface.h\n"
	    " *\tVRT_count moved to vcc_interface.h\n *\tVRT_VCL_Prevent_Cold"
	    "() and VRT_VCL_Allow_Cold() added.\n *\tVRT_vcl_get moved "
	    "to vcc_interface.h\n *\tVRT_vcl_rel moved to vcc_interface.h\n"
	    " *\tVRT_vcl_select moved to vcc_interface.h\n *\tVRT_VSA_GetPtr("
	    ") changed\n *\tVRT_ipcmp() changed\n *\tVRT_Stv_*() functions "
	    "renamed to VRT_stevedore_*()\n *\t[cache.h] WS_ReserveAll() "
	    "added\n *\t[cache.h] WS_Reserve(ws, 0) deprecated\n"
	    " * 9.0 (2019-03-15)\n *\tMake 'len' in vmod_priv 'long'\n"
	    " *\tHTTP_Copy() removed\n *\tHTTP_Dup() added\n *\tHTTP_Clone() "
	    "added\n *\tVCL_BLOB changed to newly introduced struct vrt_blob "
	    "*\n *\tVRT_blob() changed\n *\treq->req_bodybytes removed\n"
	    " *\t    use: AZ(ObjGetU64(req->wrk, req->body_oc, OA_LEN, "
	    "&u));\n *\tstruct vdi_methods .list callback signature changed\n"
	    " *\tVRT_LookupDirector() added\n *\tVRT_SetChanged() added\n"
	    " *\tVRT_SetHealth() removed\n *\t// in cache_filter.h:\n"
	    " *\tVRT_AddVDP() added\n *\tVRT_RemoveVDP() added\n"
	    " * 8.0 (2018-09-15)\n *\tVRT_Strands() added\n *\tVRT_StrandsWS("
	    ") added\n *\tVRT_CollectStrands() added\n *\tVRT_STRANDS_string("
	    ") removed from vrt.h (never implemented)\n *\tVRT_Vmod_Init "
	    "signature changed\n *\tVRT_Vmod_Fini changed to VRT_Vmod_Unload\n"
	    " *\t// directors\n *\tVRT_backend_healthy() removed\n"
	    " *\tVRT_Healthy() changed prototype\n *\tstruct vdi_methods "
	    "and callback prototypes added\n *\tstruct director added;\n"
	    " *\tVRT_AddDirector() added\n *\tVRT_SetHealth() added\n"
	    " *\tVRT_DisableDirector() added\n *\tVRT_DelDirector() added\n"
	    " *\t// in cache_filter.h:\n *\tVRT_AddVFP() added\n"
	    " *\tVRT_RemoveVFP() added\n * 7.0 (2018-03-15)\n *\tlots of "
	    "stuff moved from cache.h to cache_varnishd.h\n *\t   (ie: "
	    "from \"$Abi vrt\" to \"$Abi strict\")\n *\tVCL_INT and VCL_BYTES"
	    " are always 64 bits.\n *\tpath field added to struct vrt_backend"
	    "\n *\tVRT_Healthy() added\n *\tVRT_VSC_Alloc() added\n"
	    " *\tVRT_VSC_Destroy() added\n *\tVRT_VSC_Hide() added\n"
	    " *\tVRT_VSC_Reveal() added\n *\tVRT_VSC_Overhead() added\n"
	    " *\tstruct director.event added\n *\tstruct director.destroy "
	    "added\n *\tVRT_r_beresp_storage_hint() VCL <= 4.0  #2509\n"
	    " *\tVRT_l_beresp_storage_hint() VCL <= 4.0  #2509\n"
	    " *\tVRT_blob() added\n *\tVCL_STRANDS added\n * 6.1 (2017-09-15 "
	    "aka 5.2)\n *\thttp_CollectHdrSep added\n *\tVRT_purge modified "
	    "(may fail a transaction, signature changed)\n *\tVRT_r_req_hash("
	    ") added\n *\tVRT_r_bereq_hash() added\n * 6.0 (2017-03-15):\n"
	    " *\tVRT_hit_for_pass added\n *\tVRT_ipcmp added\n"
	    " *\tVRT_Vmod_Init signature changed\n *\tVRT_vcl_lookup removed\n"
	    " *\tVRT_fail added\n *\t[cache.h] WS_Reset and WS_Snapshot "
	    "signatures changed\n *\t[cache.h] WS_Front added\n"
	    " *\t[cache.h] WS_ReserveLumps added\n *\t[cache.h] WS_Inside "
	    "added\n *\t[cache.h] WS_Assert_Allocated added\n * 5.0:\n"
	    " *\tVarnish 5.0 release \"better safe than sorry\" bump\n"
	    " * 4.0:\n *\tVCL_BYTES changed to long long\n *\tVRT_CacheReqBod"
	    "y changed signature\n * 3.2:\n *\tvrt_backend grew .proxy_header"
	    " field\n *\tvrt_ctx grew .sp field.\n *\tvrt_acl type added\n"
	    " */\n\n#define VRT_MAJOR_VERSION\t12U\n\n#define VRT_MINOR_VERSI"
	    "ON\t0U\n\n/*****************************************************"
	    "******************/\n\n#include <stddef.h>\t\t// NULL, size_t\n"
	    "#include <stdint.h>\t\t// [u]int%d_t\n\nstruct VCL_conf;\n"
	    "struct busyobj;\nstruct director;\nstruct http;\n"
	    "struct req;\nstruct stevedore;\nstruct suckaddr;\n"
	    "struct vcl;\nstruct vmod;\nstruct vmod_priv;\nstruct vrt_acl;\n"
	    "struct vsb;\nstruct vsc_seg;\nstruct vsmw_cluster;\n"
	    "struct vsl_log;\nstruct ws;\nstruct VSC_main;\n\n"
	    "/*\n * VCL_STRANDS:\n *\n * An argc+argv type of data structure "
	    "where n indicates the number of strings\n * in the p array. "
	    "Individual components of a strands may be null.\n"
	    " *\n * A STRANDS allows you to work on a strings concatenation "
	    "with the option to\n * collect it into a single STRING, or "
	    "if possible work directly on individual\n * parts.\n"
	    " *\n * The memory management is very strict: a VMOD function "
	    "receiving a STRANDS\n * argument should keep no reference "
	    "after the function returns. Retention of\n * a STRANDS further "
	    "in the ongoing task is undefined behavior and may result\n"
	    " * in a panic or data corruption.\n */\n\nstruct strands {\n"
	    "\tint\t\tn;\n\tconst char\t**p;\n};\n\nstruct strands * VRT_Allo"
	    "cStrandsWS(struct ws *, int);\n\n\n/*\n * VCL_BLOB:\n"
	    " *\n * Opaque, immutable data (pointer + length), minimum "
	    "lifetime is the VCL task.\n *\n * Type (optional) is owned "
	    "by the creator of the blob. blob consumers may use\n"
	    " * it for checks, but should not assert on it.\n *\n"
	    " * The data behind the blob pointer is assumed to be immutable "
	    "for the blob's\n * lifetime.\n *\n * Memory management is "
	    "either implicit or up to the vmod:\n *\n * - memory for shortliv"
	    "ed blobs should come from the respective workspace\n"
	    " *\n * - management of memory for longer lived blobs is up "
	    "to the vmod\n *   (in which case the blob will probably be "
	    "embedded in an object or\n *    referenced by other state "
	    "with vcl lifetime)\n */\n\nstruct vrt_blob {\n\tunsigned\ttype;\n"
	    "\tsize_t\t\tlen;\n\tconst void\t*blob;\n};\n\n/*****************"
	    "******************************************************\n"
	    " * This is the central definition of the mapping from VCL "
	    "types to\n * C-types.  The python scripts read these from "
	    "here.\n * (alphabetic order)\n */\n\ntypedef const struct "
	    "vrt_acl *\t\t\tVCL_ACL;\ntypedef const struct director *\t\t"
	    "\tVCL_BACKEND;\ntypedef const struct vrt_blob *\t\t\tVCL_BLOB;\n"
	    "typedef const char *\t\t\t\tVCL_BODY;\ntypedef unsigned\t\t"
	    "\t\tVCL_BOOL;\ntypedef int64_t\t\t\t\t\tVCL_BYTES;\n"
	    "typedef vtim_dur\t\t\t\tVCL_DURATION;\ntypedef const char "
	    "*\t\t\t\tVCL_ENUM;\ntypedef const struct gethdr_s *\t\t\tVCL_HEA"
	    "DER;\ntypedef struct http *\t\t\t\tVCL_HTTP;\ntypedef void\t"
	    "\t\t\t\tVCL_INSTANCE;\ntypedef int64_t\t\t\t\t\tVCL_INT;\n"
	    "typedef const struct suckaddr *\t\t\tVCL_IP;\ntypedef const "
	    "struct vrt_backend_probe *\tVCL_PROBE;\ntypedef double\t\t\t"
	    "\t\tVCL_REAL;\ntypedef const struct stevedore *\t\tVCL_STEVEDORE"
	    ";\ntypedef const struct strands *\t\t\tVCL_STRANDS;\n"
	    "typedef const char *\t\t\t\tVCL_STRING;\ntypedef vtim_real\t"
	    "\t\t\tVCL_TIME;\ntypedef struct vcl *\t\t\t\tVCL_VCL;\n"
	    "typedef void\t\t\t\t\tVCL_VOID;\n\nstruct vrt_type {\n"
	    "\tunsigned\t\t\tmagic;\n#define VRT_TYPE_MAGIC\t\t\t0xa943bc32\n"
	    "\tconst char\t\t\t*lname;\n\tconst char\t\t\t*uname;\n"
	    "\tconst char\t\t\t*ctype;\n\tsize_t\t\t\t\tszof;\n"
	    "};\n\nenum lbody_e {\n\tLBODY_SET,\n\tLBODY_ADD,\n"
	    "};\n\n/*********************************************************"
	    "**************\n * This is the composite argument we pass "
	    "to compiled VCL and VRT\n * functions.\n */\n\nstruct vrt_ctx "
	    "{\n\tunsigned\t\t\tmagic;\n#define VRT_CTX_MAGIC\t\t\t0x6bb8f0db"
	    "\n\n\tunsigned\t\t\tsyntax;\n\tunsigned\t\t\tmethod;\n"
	    "\tunsigned\t\t\t*handling;\n\tunsigned\t\t\tvclver;\n"
	    "\n\t/*\n\t * msg is for error messages and exists only for\n"
	    "\t * VCL_EVENT_LOAD\n\t * VCL_EVENT_WARM\n\t */\n"
	    "\tstruct vsb\t\t\t*msg;\n\tstruct vsl_log\t\t\t*vsl;\n"
	    "\tVCL_VCL\t\t\t\tvcl;\n\tstruct ws\t\t\t*ws;\n\n\tstruct sess\t"
	    "\t\t*sp;\n\n\tstruct req\t\t\t*req;\n\tVCL_HTTP\t\t\thttp_req;\n"
	    "\tVCL_HTTP\t\t\thttp_req_top;\n\tVCL_HTTP\t\t\thttp_resp;\n"
	    "\n\tstruct busyobj\t\t\t*bo;\n\tVCL_HTTP\t\t\thttp_bereq;\n"
	    "\tVCL_HTTP\t\t\thttp_beresp;\n\n\tvtim_real\t\t\tnow;\n"
	    "\n\t/*\n\t ");
	VSB_cat(sb, "* method specific argument:\n\t *    hash:\t\tstruct"
	    " VSHA256Context\n\t *    synth+error:\tstruct vsb *\n"
	    "\t */\n\tvoid\t\t\t\t*specific;\n};\n\n#define VRT_CTX\t\tconst "
	    "struct vrt_ctx *ctx\n\n/****************************************"
	    "*******************************\n * This is the interface "
	    "structure to a compiled VMOD\n */\n\nstruct vmod_data {\n"
	    "\t/* The version/id fields must be first, they protect the "
	    "rest */\n\tunsigned\t\t\tvrt_major;\n\tunsigned\t\t\tvrt_minor;\n"
	    "\tconst char\t\t\t*file_id;\n\n\tconst char\t\t\t*name;\n"
	    "\tconst char\t\t\t*func_name;\n\tconst void\t\t\t*func;\n"
	    "\tint\t\t\t\tfunc_len;\n\tconst char\t\t\t*proto;\n"
	    "\tconst char\t\t\t*json;\n\tconst char\t\t\t*abi;\n"
	    "};\n\n/*********************************************************"
	    "**************\n * Enum for events sent to compiled VCL and "
	    "from there to Vmods\n */\n\nenum vcl_event_e {\n\tVCL_EVENT_LOAD"
	    ",\n\tVCL_EVENT_WARM,\n\tVCL_EVENT_COLD,\n\tVCL_EVENT_DISCARD,\n"
	    "};\n\n/*********************************************************"
	    "**************/\n\nextern const void * const vrt_magic_string_en"
	    "d;\nextern const void * const vrt_magic_string_unset;\n"
	    "\n/*************************************************************"
	    "**********\n * We want the VCC to spit this structs out as "
	    "const, but when VMODs\n * come up with them we want to clone "
	    "them into malloc'ed space which\n * we can free again.\n"
	    " * We collect all the knowledge here by macroizing the fields "
	    "and make\n * a macro for handling them all.\n * See also: "
	    " cache_backend.h & cache_backend_cfg.c\n * One of those things.."
	    ".\n */\n\n#define VRT_BACKEND_FIELDS(rigid)\t\t\t\t\\\n"
	    "\trigid char\t\t\t*vcl_name;\t\t\\\n\trigid char\t\t\t*ipv4_addr"
	    ";\t\t\\\n\trigid char\t\t\t*ipv6_addr;\t\t\\\n\trigid char\t"
	    "\t\t*port;\t\t\t\\\n\trigid char\t\t\t*path;\t\t\t\\\n"
	    "\trigid char\t\t\t*hosthdr;\t\t\\\n\tvtim_dur\t\t\tconnect_timeo"
	    "ut;\t\\\n\tvtim_dur\t\t\tfirst_byte_timeout;\t\\\n"
	    "\tvtim_dur\t\t\tbetween_bytes_timeout;\t\\\n\tunsigned\t\t\t"
	    "max_connections;\t\\\n\tunsigned\t\t\tproxy_header;\t\t\\\n"
	    "\tvoid\t\t\t\t*prefix_ptr;\t\t\\\n\tunsigned\t\t\tprefix_len;\n"
	    "\n#define VRT_BACKEND_HANDLE()\t\t\t\\\n\tdo {\t\t\t\t\t\\\n"
	    "\t\tDA(vcl_name);\t\t\t\\\n\t\tDA(ipv4_addr);\t\t\t\\\n"
	    "\t\tDA(ipv6_addr);\t\t\t\\\n\t\tDA(port);\t\t\t\\\n"
	    "\t\tDA(path);\t\t\t\\\n\t\tDA(hosthdr);\t\t\t\\\n"
	    "\t\tDN(connect_timeout);\t\t\\\n\t\tDN(first_byte_timeout);\t"
	    "\t\\\n\t\tDN(between_bytes_timeout);\t\\\n\t\tDN(max_connections"
	    ");\t\t\\\n\t\tDN(proxy_header);\t\t\\\n\t} while(0)\n"
	    "\nstruct vrt_backend {\n\tunsigned\t\t\tmagic;\n#define VRT_BACK"
	    "END_MAGIC\t\t0x4799ce6c\n\tVRT_BACKEND_FIELDS(const)\n"
	    "\tVCL_IP\t\t\t\tipv4_suckaddr;\n\tVCL_IP\t\t\t\tipv6_suckaddr;\n"
	    "\tVCL_PROBE\t\t\tprobe;\n};\n\n#define VRT_BACKEND_PROBE_FIELDS("
	    "rigid)\t\t\t\t\\\n\tvtim_dur\t\t\ttimeout;\t\t\\\n"
	    "\tvtim_dur\t\t\tinterval;\t\t\\\n\tunsigned\t\t\texp_status;\t"
	    "\t\\\n\tunsigned\t\t\twindow;\t\t\t\\\n\tunsigned\t\t\tthreshold"
	    ";\t\t\\\n\tunsigned\t\t\tinitial;\n\n#define VRT_BACKEND_PROBE_H"
	    "ANDLE()\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tDN(timeout);\t\t\t\\\n"
	    "\t\tDN(interval);\t\t\t\\\n\t\tDN(exp_status);\t\t\t\\\n"
	    "\t\tDN(window);\t\t\t\\\n\t\tDN(threshold);\t\t\t\\\n"
	    "\t\tDN(initial);\t\t\t\\\n\t} while (0)\n\nstruct vrt_backend_pr"
	    "obe {\n\tunsigned\t\t\tmagic;\n#define VRT_BACKEND_PROBE_MAGIC\t"
	    "\t0x84998490\n\tconst char\t\t\t*url;\n\tconst char\t\t\t*reques"
	    "t;\n\tVRT_BACKEND_PROBE_FIELDS(const)\n};\n\nVCL_BACKEND VRT_Dir"
	    "ectorResolve(VRT_CTX, VCL_BACKEND);\n\n/************************"
	    "***********************************************\n"
	    " * Implementation details of ACLs\n */\n\nvoid VRT_acl_log(VRT_C"
	    "TX, const char *);\nint VRT_acl_match(VRT_CTX, VCL_ACL, VCL_IP);"
	    "\n\n/***********************************************************"
	    "************\n * Compile time regexp\n */\n\nvoid VRT_re_init(vo"
	    "id **, const char *);\nvoid VRT_re_fini(void *);\n"
	    "int VRT_re_match(VRT_CTX, const char *, void *);\n"
	    "\n/*************************************************************"
	    "**********\n * Getting hold of the various struct http\n"
	    " */\n\nenum gethdr_e {\n\tHDR_REQ,\n\tHDR_REQ_TOP,\n"
	    "\tHDR_RESP,\n\tHDR_OBJ,\n\tHDR_BEREQ,\n\tHDR_BERESP\n"
	    "};\n\nstruct gethdr_s {\n\tenum gethdr_e\twhere;\n"
	    "\tconst char\t*what;\n};\n\nVCL_HTTP VRT_selecthttp(VRT_CTX, "
	    "enum gethdr_e);\nVCL_STRING VRT_GetHdr(VRT_CTX, VCL_HEADER);\n"
	    "\n/*************************************************************"
	    "**********\n * req related\n */\n\nVCL_BYTES VRT_CacheReqBody(VR"
	    "T_CTX, VCL_BYTES maxsize);\n\n/* Regexp related */\n"
	    "\nconst char *VRT_regsub(VRT_CTX, int all, const char *, void "
	    "*, const char *);\nVCL_VOID VRT_ban_string(VRT_CTX, VCL_STRING);"
	    "\nVCL_INT VRT_purge(VRT_CTX, VCL_DURATION, VCL_DURATION, VCL_DUR"
	    "ATION);\nVCL_VOID VRT_synth(VRT_CTX, VCL_INT, VCL_STRING);\n"
	    "VCL_VOID VRT_hit_for_pass(VRT_CTX, VCL_DURATION);\n"
	    "\nVCL_VOID VRT_SetHdr(VRT_CTX, VCL_HEADER, const char *, ...);\n"
	    "VCL_VOID VRT_handling(VRT_CTX, unsigned hand);\nVCL_VOID VRT_fai"
	    "l(VRT_CTX, const char *fmt, ...) v_printflike_(2,3);\n"
	    "VCL_VOID VRT_hashdata(VRT_CTX, VCL_STRANDS);\n\n/* Simple "
	    "stuff */\nint VRT_strcmp(const char *s1, const char *s2);\n"
	    "void VRT_memmove(void *dst, const void *src, unsigned len);\n"
	    "VCL_BOOL VRT_ipcmp(VRT_CTX, VCL_IP, VCL_IP);\nVCL_BLOB VRT_blob("
	    "VRT_CTX, const char *, const void *, size_t, unsigned);\n"
	    "\nVCL_VOID VRT_Rollback(VRT_CTX, VCL_HTTP);\n\n/* Synthetic "
	    "pages */\nVCL_VOID VRT_synth_page(VRT_CTX, VCL_STRANDS);\n"
	    "\n/* Backend related */\nVCL_BACKEND VRT_new_backend(VRT_CTX, "
	    "const struct vrt_backend *);\nVCL_BACKEND VRT_new_backend_cluste"
	    "red(VRT_CTX,\n    struct vsmw_cluster *, const struct vrt_backen"
	    "d *);\nsize_t VRT_backend_vsm_need(VRT_CTX);\nvoid VRT_delete_ba"
	    "ckend(VRT_CTX, VCL_BACKEND *);\n\n/* VSM related */\n"
	    "struct vsmw_cluster *VRT_VSM_Cluster_New(VRT_CTX, size_t);\n"
	    "void VRT_VSM_Cluster_Destroy(VRT_CTX, struct vsmw_cluster "
	    "**);\n\n/* VDI - Director API */\ntypedef VCL_BOOL vdi_healthy_f"
	    "(VRT_CTX, VCL_BACKEND, VCL_TIME *);\ntypedef VCL_BACKEND vdi_res"
	    "olve_f(VRT_CTX, VCL_BACKEND);\ntypedef int vdi_gethdrs_f(VRT_CTX"
	    ", VCL_BACKEND);\ntypedef VCL_IP vdi_getip_f(VRT_CTX, VCL_BACKEND"
	    ");\ntypedef void vdi_finish_f(VRT_CTX, VCL_BACKEND);\n"
	    "typedef enum sess_close vdi_http1pipe_f(VRT_CTX, VCL_BACKEND);\n"
	    "typedef void vdi_event_f(VCL_BACKEND, enum vcl_event_e);\n"
	    "typedef void vdi_destroy_f(VCL_BACKEND);\ntypedef void vdi_panic"
	    "_f(VCL_BACKEND, struct vsb *);\ntypedef void vdi_list_f(VRT_CTX,"
	    " VCL_BACKEND, struct vsb *, int, int);\n\nstruct vdi_methods "
	    "{\n\tunsigned\t\t\tmagic;\n#define VDI_METHODS_MAGIC\t\t0x4ec0c4"
	    "bb\n\tconst char\t\t\t*type;\n\tvdi_http1pipe_f\t\t\t*http1pipe;"
	    "\n\tvdi_healthy_f\t\t\t*healthy;\n\tvdi_resolve_f\t\t\t*resolve;"
	    "\n\tvdi_gethdrs_f\t\t\t*gethdrs;\n\tvdi_getip_f\t\t\t*getip;\n"
	    "\tvdi_finish_f\t\t\t*finish;\n\tvdi_event_f\t\t\t*event;\n"
	    "\tvdi_destroy_f\t\t\t*destroy;\n\tvdi_panic_f\t\t\t*panic;\n"
	    "\tvdi_list_f\t\t\t*list;\n};\n\nstruct vcldir;\n\n"
	    "struct director {\n\tunsigned\t\t\tmagic;\n#define DIRECTOR_MAGI"
	    "C\t\t\t0x3336351d\n\tvoid\t\t\t\t*priv;\n\tchar\t\t\t\t*vcl_name"
	    ";\n\tstruct vcldir\t\t\t*vdir;\n};\n\nVCL_BOOL VRT_Healthy(VRT_C"
	    "TX, VCL_BACKEND, VCL_TIME *);\nVCL_VOID VRT_SetChanged(VCL_BACKE"
	    "ND, VCL_TIME);\nVCL_BACKEND VRT_AddDirector(VRT_CTX, const "
	    "struct vdi_methods *,\n    void *, const char *, ...) v_printfli"
	    "ke_(4, 5);\nvoid VRT_DisableDirector(VCL_BACKEND);\n"
	    "VCL_BACKEND VRT_LookupDirector(VRT_CTX, VCL_STRING);\n"
	    "void VRT_DelDirector(VCL_BACKEND *);\n\n/* Suckaddr related "
	    "*/\nint VRT_VSA_GetPtr(VRT_CTX, VCL_IP sua, const unsigned "
	    "char ** dst);\n/* transitional interface */\nvoid VRT_Format_Pro"
	    "xy(struct vsb *, VCL_INT, VCL_IP, VCL_IP, VCL_STRING);\n"
	    "\ntypedef int vmod_event_f(VRT_CTX, struct vmod_priv *, enum "
	    "vcl_event_e);\n\ntypedef void vmod_priv_free_f(void *);\n"
	    "struct vmod_priv {\n\tvoid\t\t\t*priv;\n\tlong\t\t\tlen;\n"
	    "\tvmod_priv_free_f\t*free;\n};\n\nvoid VRT_priv_fini(const "
	    "struct vmod_priv *p);\nstruct vmod_priv *VRT_priv_task(VRT_CTX, "
	    "const void *vmod_id);\nstruct vmod_priv *VRT_priv_top(VRT_CTX, "
	    "const void *vmod_id);\n\n/* Stevedore related functions */\n"
	    "int VRT_Stv(const char *nm);\nVCL_STEVEDORE VRT_stevedore(const "
	    "char *nm);\n\n/* Convert things to string */\n\nint VRT_CompareS"
	    "trands(VCL_STRANDS a, VCL_STRANDS b);\nVCL_BOOL VRT_Strands2Bool"
	    "(VCL_STRANDS);\nuint32_t VRT_HashStrands32(VCL_STRANDS);\n"
	    "char *VRT_Strands(char *, size_t, VCL_STRANDS);\n"
	    "VCL_STRING VRT_StrandsWS(struct ws *, const char *, VCL_STRANDS)"
	    ";\nVCL_STRING VRT_CollectStrands(VRT_CTX, VCL_STRANDS);\n"
	    "VCL_STRING VRT_UpperLowerStrands(VRT_CTX, VCL_STRANDS s, int "
	    "up);\n\nVCL_STRING VRT_BACKEND_string(VCL_BACKEND);\n"
	    "VCL_STRING VRT_BOOL_string(VCL_BOOL);\nVCL_STRING VRT_BLOB_strin"
	    "g(VRT_CTX, VCL_BLOB);\nVCL_STRING VRT_CollectString(VRT_CTX, "
	    "const char *p, ...);\nVCL_STRING VRT_INT_string(VRT_CTX, VCL_INT"
	    ");\nVCL_STRING VRT_IP_string(VRT_CTX, VCL_IP);\nVCL_STRING "
	    "VRT_REAL_string(VRT_CTX, VCL_REAL);\nVCL_STRING VRT_STEVEDORE_st"
	    "ring(VCL_STEVEDORE);\nVCL_STRING VRT_TIME_string(VRT_CTX, "
	    "VCL_TIME);\n\n#ifdef va_start\t// XXX: hackish\nvoid *VRT_VSC_Al"
	    "loc(struct vsmw_cluster *, struct vsc_seg **,\n    const char "
	    "*, size_t, const unsigned char *, size_t, const char *, va_list)"
	    ";\n#endif\nvoid VRT_VSC_Destroy(const char *, struct vsc_seg "
	    "*);\nvoid VRT_VSC_Hide(const struct vsc_seg *);\n"
	    "void VRT_VSC_Reveal(const struct vsc_seg *);\nsize_t VRT_VSC_Ove"
	    "rhead(size_t);\n\n/*\n * API to restrict the VCL in various "
	    "ways\n */\n\nstruct vclref;\nstruct vclref * VRT_VCL_Prevent_Col"
	    "d(VRT_CTX, const char *);\nvoid VRT_VCL_Allow_Cold(struct "
	    "vclref **);\n\nstruct vclref * VRT_VCL_Prevent_Discard(VRT_CTX, "
	    "const char *);\nvoid VRT_VCL_Allow_Discard(struct vclref **);\n"
	);
	VSB_cat(sb, "\n");

	/* ../include/vcl.h */

	VSB_cat(sb, "/* ---===### include/vcl.h ###===--- */\n\n");
	VSB_cat(sb, "/*\n * NB:  This file is machine generated, DO "
	    "NOT EDIT!\n *\n * Edit and run lib/libvcc/generate.py instead.\n"
	    " */\n\n\n#ifdef VCL_H_INCLUDED\n#  error \"vcl.h included "
	    "multiple times\"\n#endif\n#define VCL_H_INCLUDED\n"
	    "\n#ifndef VRT_H_INCLUDED\n#  error \"include vrt.h before "
	    "vcl.h\"\n#endif\n\n/* VCL Methods */\n#define VCL_MET_RECV\t"
	    "\t\t(1U << 1)\n#define VCL_MET_PIPE\t\t\t(1U << 2)\n"
	    "#define VCL_MET_PASS\t\t\t(1U << 3)\n#define VCL_MET_HASH\t"
	    "\t\t(1U << 4)\n#define VCL_MET_PURGE\t\t\t(1U << 5)\n"
	    "#define VCL_MET_MISS\t\t\t(1U << 6)\n#define VCL_MET_HIT\t\t"
	    "\t(1U << 7)\n#define VCL_MET_DELIVER\t\t\t(1U << 8)\n"
	    "#define VCL_MET_SYNTH\t\t\t(1U << 9)\n#define VCL_MET_BACKEND_FE"
	    "TCH\t\t(1U << 10)\n#define VCL_MET_BACKEND_RESPONSE\t(1U << "
	    "11)\n#define VCL_MET_BACKEND_ERROR\t\t(1U << 12)\n"
	    "#define VCL_MET_INIT\t\t\t(1U << 13)\n#define VCL_MET_FINI\t"
	    "\t\t(1U << 14)\n\n#define VCL_MET_MAX\t\t\t15\n\n"
	    "#define VCL_MET_MASK\t\t\t0x7fff\n\n#define VCL_MET_TASK_B\t"
	    "\t\t( VCL_MET_BACKEND_FETCH | \\\n\t\t\t\t\t  VCL_MET_BACKEND_RE"
	    "SPONSE | \\\n\t\t\t\t\t  VCL_MET_BACKEND_ERROR )\n"
	    "#define VCL_MET_TASK_C\t\t\t( VCL_MET_RECV | \\\n"
	    "\t\t\t\t\t  VCL_MET_PIPE | \\\n\t\t\t\t\t  VCL_MET_PASS | "
	    "\\\n\t\t\t\t\t  VCL_MET_HASH | \\\n\t\t\t\t\t  VCL_MET_PURGE "
	    "| \\\n\t\t\t\t\t  VCL_MET_MISS | \\\n\t\t\t\t\t  VCL_MET_HIT "
	    "| \\\n\t\t\t\t\t  VCL_MET_DELIVER | \\\n\t\t\t\t\t  VCL_MET_SYNT"
	    "H )\n#define VCL_MET_TASK_H\t\t\t( VCL_MET_INIT | \\\n"
	    "\t\t\t\t\t  VCL_MET_FINI )\n\n/* VCL Returns */\n"
	    "#define VCL_RET_ABANDON\t\t\t1\n#define VCL_RET_DELIVER\t\t"
	    "\t2\n#define VCL_RET_ERROR\t\t\t3\n#define VCL_RET_FAIL\t\t"
	    "\t4\n#define VCL_RET_FETCH\t\t\t5\n#define VCL_RET_HASH\t\t"
	    "\t6\n#define VCL_RET_LOOKUP\t\t\t7\n#define VCL_RET_OK\t\t\t"
	    "8\n#define VCL_RET_PASS\t\t\t9\n#define VCL_RET_PIPE\t\t\t10\n"
	    "#define VCL_RET_PURGE\t\t\t11\n#define VCL_RET_RESTART\t\t\t"
	    "12\n#define VCL_RET_RETRY\t\t\t13\n#define VCL_RET_SYNTH\t\t"
	    "\t14\n#define VCL_RET_VCL\t\t\t15\n\n#define VCL_RET_MAX\t\t"
	    "\t16\n\n/* VCL Types */\nextern const struct vrt_type VCL_TYPE_A"
	    "CL[1];\nextern const struct vrt_type VCL_TYPE_BACKEND[1];\n"
	    "extern const struct vrt_type VCL_TYPE_BLOB[1];\nextern const "
	    "struct vrt_type VCL_TYPE_BODY[1];\nextern const struct vrt_type "
	    "VCL_TYPE_BOOL[1];\nextern const struct vrt_type VCL_TYPE_BYTES[1"
	    "];\nextern const struct vrt_type VCL_TYPE_DURATION[1];\n"
	    "extern const struct vrt_type VCL_TYPE_ENUM[1];\nextern const "
	    "struct vrt_type VCL_TYPE_HEADER[1];\nextern const struct vrt_typ"
	    "e VCL_TYPE_HTTP[1];\nextern const struct vrt_type VCL_TYPE_INSTA"
	    "NCE[1];\nextern const struct vrt_type VCL_TYPE_INT[1];\n"
	    "extern const struct vrt_type VCL_TYPE_IP[1];\nextern const "
	    "struct vrt_type VCL_TYPE_PROBE[1];\nextern const struct vrt_type"
	    " VCL_TYPE_REAL[1];\nextern const struct vrt_type VCL_TYPE_STEVED"
	    "ORE[1];\nextern const struct vrt_type VCL_TYPE_STRANDS[1];\n"
	    "extern const struct vrt_type VCL_TYPE_STRING[1];\n"
	    "extern const struct vrt_type VCL_TYPE_STRINGS[1];\n"
	    "extern const struct vrt_type VCL_TYPE_STRING_LIST[1];\n"
	    "extern const struct vrt_type VCL_TYPE_SUB[1];\nextern const "
	    "struct vrt_type VCL_TYPE_TIME[1];\nextern const struct vrt_type "
	    "VCL_TYPE_VCL[1];\nextern const struct vrt_type VCL_TYPE_VOID[1];"
	    "\n\n/* Compiled VCL Interface */\ntypedef int vcl_event_f(VRT_CT"
	    "X, enum vcl_event_e);\ntypedef int vcl_init_f(VRT_CTX);\n"
	    "typedef void vcl_fini_f(VRT_CTX);\ntypedef void vcl_func_f(VRT_C"
	    "TX);\n\nstruct VCL_conf {\n\tunsigned\t\tmagic;\n"
	    "#define VCL_CONF_MAGIC\t\t0x7406c509      /* from /dev/random "
	    "*/\n\n\tunsigned\t\tsyntax;\n\tVCL_BACKEND\t\t*default_director;"
	    "\n\tVCL_PROBE\t\tdefault_probe;\n\tunsigned\t\tnref;\n"
	    "\tconst struct vpi_ref\t*ref;\n\n\tint\t\t\tnsrc;\n"
	    "\tconst char\t\t**srcname;\n\tconst char\t\t**srcbody;\n"
	    "\n\tint\t\t\tnvmod;\n\tconst struct vpi_ii\t*instance_info;\n"
	    "\n\tvcl_event_f\t\t*event_vcl;\n\tvcl_func_f\t\t*recv_func;\n"
	    "\tvcl_func_f\t\t*pipe_func;\n\tvcl_func_f\t\t*pass_func;\n"
	    "\tvcl_func_f\t\t*hash_func;\n\tvcl_func_f\t\t*purge_func;\n"
	    "\tvcl_func_f\t\t*miss_func;\n\tvcl_func_f\t\t*hit_func;\n"
	    "\tvcl_func_f\t\t*deliver_func;\n\tvcl_func_f\t\t*synth_func;\n"
	    "\tvcl_func_f\t\t*backend_fetch_func;\n\tvcl_func_f\t\t*backend_r"
	    "esponse_func;\n\tvcl_func_f\t\t*backend_error_func;\n"
	    "\tvcl_func_f\t\t*init_func;\n\tvcl_func_f\t\t*fini_func;\n"
	    "\n};\n"
	);
	VSB_cat(sb, "\n");

	/* ../include/vrt_obj.h */

	VSB_cat(sb, "/* ---===### include/vrt_obj.h ###===--- */\n\n");
	VSB_cat(sb, "/*\n * NB:  This file is machine generated, DO "
	    "NOT EDIT!\n *\n * Edit and run lib/libvcc/generate.py instead.\n"
	    " */\n\n\nVCL_IP VRT_r_local_ip(VRT_CTX);\n\nVCL_STRING VRT_r_loc"
	    "al_endpoint(VRT_CTX);\n\nVCL_STRING VRT_r_local_socket(VRT_CTX);"
	    "\n\nVCL_IP VRT_r_remote_ip(VRT_CTX);\n\nVCL_IP VRT_r_client_ip(V"
	    "RT_CTX);\n\nVCL_STRING VRT_r_client_identity(VRT_CTX);\n"
	    "void VRT_l_client_identity(VRT_CTX, const char *, ...);\n"
	    "\nVCL_IP VRT_r_server_ip(VRT_CTX);\n\nVCL_STRING VRT_r_server_ho"
	    "stname(VRT_CTX);\n\nVCL_STRING VRT_r_server_identity(VRT_CTX);\n"
	    "\nVCL_HTTP VRT_r_req(VRT_CTX);\n\nVCL_STRING VRT_r_req_method(VR"
	    "T_CTX);\nvoid VRT_l_req_method(VRT_CTX, const char *, ...);\n"
	    "\nVCL_BLOB VRT_r_req_hash(VRT_CTX);\n\nVCL_STRING VRT_r_req_url("
	    "VRT_CTX);\nvoid VRT_l_req_url(VRT_CTX, const char *, ...);\n"
	    "\nVCL_STRING VRT_r_req_proto(VRT_CTX);\nvoid VRT_l_req_proto(VRT"
	    "_CTX, const char *, ...);\n\n\nvoid VRT_u_req_http(VRT_CTX);\n"
	    "\nVCL_INT VRT_r_req_restarts(VRT_CTX);\n\nVCL_STEVEDORE VRT_r_re"
	    "q_storage(VRT_CTX);\nvoid VRT_l_req_storage(VRT_CTX, VCL_STEVEDO"
	    "RE);\n\nVCL_INT VRT_r_req_esi_level(VRT_CTX);\n\n"
	    "VCL_DURATION VRT_r_req_ttl(VRT_CTX);\nvoid VRT_l_req_ttl(VRT_CTX"
	    ", VCL_DURATION);\n\nVCL_DURATION VRT_r_req_grace(VRT_CTX);\n"
	    "void VRT_l_req_grace(VRT_CTX, VCL_DURATION);\n\nVCL_STRING "
	    "VRT_r_req_xid(VRT_CTX);\n\nVCL_BOOL VRT_r_req_esi(VRT_CTX);\n"
	    "void VRT_l_req_esi(VRT_CTX, VCL_BOOL);\n\nVCL_BOOL VRT_r_req_can"
	    "_gzip(VRT_CTX);\n\nVCL_BACKEND VRT_r_req_backend_hint(VRT_CTX);\n"
	    "void VRT_l_req_backend_hint(VRT_CTX, VCL_BACKEND);\n"
	    "\nVCL_BOOL VRT_r_req_hash_ignore_busy(VRT_CTX);\n"
	    "void VRT_l_req_hash_ignore_busy(VRT_CTX, VCL_BOOL);\n"
	    "\nVCL_BOOL VRT_r_req_hash_always_miss(VRT_CTX);\n"
	    "void VRT_l_req_hash_always_miss(VRT_CTX, VCL_BOOL);\n"
	    "\nVCL_BOOL VRT_r_req_is_hitmiss(VRT_CTX);\n\nVCL_BOOL VRT_r_req_"
	    "is_hitpass(VRT_CTX);\n\nVCL_STRING VRT_r_req_top_method(VRT_CTX)"
	    ";\n\nVCL_STRING VRT_r_req_top_url(VRT_CTX);\n\n\n"
	    "VCL_STRING VRT_r_req_top_proto(VRT_CTX);\n\nVCL_HTTP VRT_r_bereq"
	    "(VRT_CTX);\n\nVCL_STRING VRT_r_bereq_xid(VRT_CTX);\n"
	    "\nVCL_INT VRT_r_bereq_retries(VRT_CTX);\n\nVCL_BACKEND VRT_r_ber"
	    "eq_backend(VRT_CTX);\nvoid VRT_l_bereq_backend(VRT_CTX, VCL_BACK"
	    "END);\n\nvoid VRT_u_bereq_body(VRT_CTX);\n\nVCL_BLOB VRT_r_bereq"
	    "_hash(VRT_CTX);\n\nVCL_STRING VRT_r_bereq_method(VRT_CTX);\n"
	    "void VRT_l_bereq_method(VRT_CTX, const char *, ...);\n"
	    "\nVCL_STRING VRT_r_bereq_url(VRT_CTX);\nvoid VRT_l_bereq_url(VRT"
	    "_CTX, const char *, ...);\n\nVCL_STRING VRT_r_bereq_proto(VRT_CT"
	    "X);\nvoid VRT_l_bereq_proto(VRT_CTX, const char *, ...);\n"
	    "\n\nvoid VRT_u_bereq_http(VRT_CTX);\n\nVCL_BOOL VRT_r_bereq_unca"
	    "cheable(VRT_CTX);\n\nVCL_DURATION VRT_r_bereq_connect_timeout(VR"
	    "T_CTX);\nvoid VRT_l_bereq_connect_timeout(VRT_CTX, VCL_DURATION)"
	    ";\n\nVCL_DURATION VRT_r_bereq_first_byte_timeout(VRT_CTX);\n"
	    "void VRT_l_bereq_first_byte_timeout(VRT_CTX, VCL_DURATION);\n"
	    "\nVCL_DURATION VRT_r_bereq_between_bytes_timeout(VRT_CTX);\n"
	    "void VRT_l_bereq_between_bytes_timeout(VRT_CTX, VCL_DURATION);\n"
	    "\nVCL_BOOL VRT_r_bereq_is_bgfetch(VRT_CTX);\n\nVCL_HTTP VRT_r_be"
	    "resp(VRT_CTX);\n\nvoid VRT_l_beresp_body(VRT_CTX, enum lbody_e, "
	    "const char *, ...);\n\nVCL_STRING VRT_r_beresp_proto(VRT_CTX);\n"
	    "void VRT_l_beresp_proto(VRT_CTX, const char *, ...);\n"
	    "\n\nVCL_INT VRT_r_beresp_status(VRT_CTX);\nvoid VRT_l_beresp_sta"
	    "tus(VRT_CTX, VCL_INT);\n\nVCL_STRING VRT_r_beresp_reason(VRT_CTX"
	    ");\nvoid VRT_l_beresp_reason(VRT_CTX, const char *, ...);\n"
	    "\nvoid VRT_u_beresp_http(VRT_CTX);\n\nVCL_BOOL VRT_r_beresp_do_e"
	    "si(VRT_CTX);\nvoid VRT_l_beresp_do_esi(VRT_CTX, VCL_BOOL);\n"
	    "\nVCL_BOOL VRT_r_beresp_do_stream(VRT_CTX);\nvoid VRT_l_beresp_d"
	    "o_stream(VRT_CTX, VCL_BOOL);\n\nVCL_BOOL VRT_r_beresp_do_gzip(VR"
	    "T_CTX);\nvoid VRT_l_beresp_do_gzip(VRT_CTX, VCL_BOOL);\n"
	    "\nVCL_BOOL VRT_r_beresp_do_gunzip(VRT_CTX);\nvoid VRT_l_beresp_d"
	    "o_gunzip(VRT_CTX, VCL_BOOL);\n\nVCL_BOOL VRT_r_beresp_was_304(VR"
	    "T_CTX);\n\nVCL_BOOL VRT_r_beresp_uncacheable(VRT_CTX);\n"
	    "void VRT_l_beresp_uncacheable(VRT_CTX, VCL_BOOL);\n"
	    "\nVCL_DURATION VRT_r_beresp_ttl(VRT_CTX);\nvoid VRT_l_beresp_ttl"
	    "(VRT_CTX, VCL_DURATION);\n\nVCL_DURATION VRT_r_beresp_age(VRT_CT"
	    "X);\n\nVCL_DURATION VRT_r_beresp_grace(VRT_CTX);\n"
	    "void VRT_l_beresp_grace(VRT_CTX, VCL_DURATION);\n"
	    "\nVCL_DURATION VRT_r_beresp_keep(VRT_CTX);\nvoid VRT_l_beresp_ke"
	    "ep(VRT_CTX, VCL_DURATION);\n\nVCL_BACKEND VRT_r_beresp_backend(V"
	    "RT_CTX);\n\nVCL_STRING VRT_r_beresp_backend_name(VRT_CTX);\n"
	    "\nVCL_IP VRT_r_beresp_backend_ip(VRT_CTX);\n\nVCL_STEVEDORE "
	    "VRT_r_beresp_storage(VRT_CTX);\nvoid VRT_l_beresp_storage(VRT_CT"
	    "X, VCL_STEVEDORE);\n\nVCL_STRING VRT_r_beresp_storage_hint(VRT_C"
	    "TX);\nvoid VRT_l_beresp_storage_hint(VRT_CTX, const char *, "
	    "...);\n\nVCL_STRING VRT_r_beresp_filters(VRT_CTX);\n"
	    "void VRT_l_beresp_filters(VRT_CTX, const char *, ...);\n"
	    "\nVCL_STRING VRT_r_obj_proto(VRT_CTX);\n\nVCL_INT VRT_r_obj_stat"
	    "us(VRT_CTX);\n\nVCL_STRING VRT_r_obj_reason(VRT_CTX);\n"
	    "\nVCL_INT VRT_r_obj_hits(VRT_CTX);\n\n\nVCL_DURATION VRT_r_obj_t"
	    "tl(VRT_CTX);\n\nVCL_DURATION VRT_r_obj_age(VRT_CTX);\n"
	    "\nVCL_DURATION VRT_r_obj_grace(VRT_CTX);\n\nVCL_DURATION VRT_r_o"
	    "bj_keep(VRT_CTX);\n\nVCL_BOOL VRT_r_obj_uncacheable(VRT_CTX);\n"
	    "\nVCL_STEVEDORE VRT_r_obj_storage(VRT_CTX);\n\nVCL_BOOL VRT_r_ob"
	    "j_can_esi(VRT_CTX);\n\nVCL_HTTP VRT_r_resp(VRT_CTX);\n"
	    "\nvoid VRT_l_resp_body(VRT_CTX, enum lbody_e, const char *, "
	    "...);\n\nVCL_STRING VRT_r_resp_proto(VRT_CTX);\nvoid VRT_l_resp_"
	    "proto(VRT_CTX, const char *, ...);\n\n\nVCL_INT VRT_r_resp_statu"
	    "s(VRT_CTX);\nvoid VRT_l_resp_status(VRT_CTX, VCL_INT);\n"
	    "\nVCL_STRING VRT_r_resp_reason(VRT_CTX);\nvoid VRT_l_resp_reason"
	    "(VRT_CTX, const char *, ...);\n\nvoid VRT_u_resp_http(VRT_CTX);\n"
	    "\nVCL_BOOL VRT_r_resp_do_esi(VRT_CTX);\nvoid VRT_l_resp_do_esi(V"
	    "RT_CTX, VCL_BOOL);\n\nVCL_BOOL VRT_r_resp_is_streaming(VRT_CTX);"
	    "\n\nVCL_STRING VRT_r_resp_filters(VRT_CTX);\nvoid VRT_l_resp_fil"
	    "ters(VRT_CTX, const char *, ...);\n\nVCL_TIME VRT_r_now(VRT_CTX)"
	    ";\n\nVCL_STRING VRT_r_sess_xid(VRT_CTX);\n\nVCL_DURATION VRT_r_s"
	    "ess_timeout_idle(VRT_CTX);\nvoid VRT_l_sess_timeout_idle(VRT_CTX"
	    ", VCL_DURATION);\n\nVCL_DURATION VRT_r_sess_timeout_linger(VRT_C"
	    "TX);\nvoid VRT_l_sess_timeout_linger(VRT_CTX, VCL_DURATION);\n"
	    "\nVCL_DURATION VRT_r_sess_send_timeout(VRT_CTX);\n"
	    "void VRT_l_sess_send_timeout(VRT_CTX, VCL_DURATION);\n"
	    "\nVCL_DURATION VRT_r_sess_idle_send_timeout(VRT_CTX);\n"
	    "void VRT_l_sess_idle_send_timeout(VRT_CTX, VCL_DURATION);\n"
	    "int64_t VRT_stevedore_free_space(VCL_STEVEDORE);\n"
	    "int64_t VRT_stevedore_used_space(VCL_STEVEDORE);\n"
	    "unsigned VRT_stevedore_happy(VCL_STEVEDORE);\n"
	);
	VSB_cat(sb, "\n");

	/* ../include/vcc_interface.h */

	VSB_cat(sb, "/* ---===### include/vcc_interface.h ###===--- */\n\n");
	VSB_cat(sb, "/*-\n * Copyright (c) 2006 Verdens Gang AS\n"
	    " * Copyright (c) 2006-2019 Varnish Software AS\n * All rights "
	    "reserved.\n *\n * Author: Poul-Henning Kamp <phk@phk.freebsd.dk>"
	    "\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *\n"
	    " * Redistribution and use in source and binary forms, with "
	    "or without\n * modification, are permitted provided that the "
	    "following conditions\n * are met:\n * 1. Redistributions of "
	    "source code must retain the above copyright\n *    notice, "
	    "this list of conditions and the following disclaimer.\n"
	    " * 2. Redistributions in binary form must reproduce the above "
	    "copyright\n *    notice, this list of conditions and the followi"
	    "ng disclaimer in the\n *    documentation and/or other materials"
	    " provided with the distribution.\n *\n * THIS SOFTWARE IS "
	    "PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n"
	    " * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED"
	    " TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS "
	    "FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT "
	    "SHALL AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, "
	    "INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
	    " * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
	    "SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS;"
	    " OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY "
	    "OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR "
	    "TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n"
	    " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE "
	    "POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Runtime support for "
	    "compiled VCL programs and VMODs.\n *\n * This file contains "
	    "prototypes for functions nobody but VCC may call.\n"
	    " *\n * NB: When this file is changed, lib/libvcc/generate.py "
	    "*MUST* be rerun.\n */\n\nVCL_VCL VPI_vcl_get(VRT_CTX, const "
	    "char *);\nvoid VPI_vcl_rel(VRT_CTX, VCL_VCL);\nvoid VPI_vcl_sele"
	    "ct(VRT_CTX, VCL_VCL);\n\n/**************************************"
	    "*********************************\n * VPI_count() refers to "
	    "this structure for coordinates into the VCL source.\n"
	    " */\n\nstruct vpi_ref {\n\tunsigned\tsource;\n\tunsigned\toffset"
	    ";\n\tunsigned\tline;\n\tunsigned\tpos;\n\tconst char\t*token;\n"
	    "};\n\nvoid VPI_count(VRT_CTX, unsigned);\n\nint VPI_Vmod_Init(VR"
	    "T_CTX, struct vmod **hdl, unsigned nbr, void *ptr, int len,\n"
	    "    const char *nm, const char *path, const char *file_id, "
	    "const char *backup);\nvoid VPI_Vmod_Unload(struct vmod **hdl);\n"
	    "\ntypedef int acl_match_f(VRT_CTX, const VCL_IP);\n"
	    "\nstruct vrt_acl {\n\tunsigned        magic;\n#define VRT_ACL_MA"
	    "GIC   0x78329d96\n\tacl_match_f     *match;\n\tconst char\t"
	    "*name;\n};\n\n/* vmod object instance info */\nstruct vpi_ii "
	    "{\n\tconst void *\t\t\tp;\n\tconst char * const\t\tname;\n"
	    "};\n\nVCL_STRANDS VPI_BundleStrands(int, struct strands *, "
	    "char const **,\n    const char *f, ...);\n"
	);
	VSB_cat(sb, "\n");

}
